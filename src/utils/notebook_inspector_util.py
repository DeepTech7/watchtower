# (((((((((((((##########%%%#((((((((((((((((((((((((((((((((((((((((##%%%%%%%%%%###%#/,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
# (((((((((((((((((##########%%%##(((((((((((((((((((((((((((((##%%%%%%%%%%####(*,........,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
# (((((((((((((((((((((((#########%%%%&&&&%#(((((((((##%&&&&&&%%%%%%##%##/,,,..,...,,,.......,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
# ((((((((((((((((((((((((((((#&@#((/((((((((((((((((((((((((((((#@%...,,,,...................,,,,,,,,,,,,,,,,,,,,,,,,,,,,
# (((((((((((((((((((((((((%@(((((((((((((((((((((((((((((((((((((((((#&&*...................,..,,,,,,,,,,,,,,,,,,,,,,,,,,
# ((((((((((((((((((((#((&#((((((((((((((((((((((((((((((((((((((((((((((((%&/..,.,...............,,,,,,,,,,,,,,,,,,,,,,,,
# %%%#(((((((((((((((((&(((((((((((((((((((((((((((((((((((((((((((((((((((((((&#,...,.............,,,,,,,,,,,,,,,,,,,,,,,
# ####%%###((((((((((%%((((((((((((((((((((((((((/((((((((((((((((((((((((((((((((%#,..,,........,...,,,,,,,,,,,,,,,,,,,,,
# ((#######%%%##(((#&#((((((((((((((((((((((((/((//((((((((((((((((((((((((((((((((((&/................,,,,,,,,,,,,,,,,,,,
# ((((((#####%%%%%%&#((((((((((((((((((((((##//*///(%((((((((((((((((((((((((((((((((((%%////*.....,....,,,,,,,,,,,,,,,,,,
# ((((##%%%%%%%%%%&%((((((((((((((((((((((#///%(*////*#((((((((#(((((((((((((((((((((((((#%(((((%&*.,..,..,,,,,,,,,,,,,,,,
# %%%%%%##%#(/,.,.%((((((((((((((((((((((#*/((#&(//*/*/%(((((((/(%#(((((((((((((((((((((((((%(((((%(.,......,,,,,,,,,,,,,,
# %%##/....,,....,%((((((((((((((((((((((%**/AISHIELD*/#((((((((((/(%#(((((((((((((((((((((((((((((&.,.......,,,,,,,,,,,,,
# ................/&((((((((((&(/(((((((((#(*/(((/(**(#(((((((((((((((((%#((((((((((((((((((((((((&*.,,........,,,,,,,,,,,
# ................./#(((((((((/%((((((((((/(((#%%%##(((((((((((((((((((((((((%%#/(((((((((((((((&(..,..........,,,,,,,,,,,
# ................,.*@((((((((((%(((((((((((((((((((((((((#######%%#####((((((((((((###%%#&%(*,.....,.........,...,,,,,,,,
# ..................,.,&%((((((((#(((((((/((#%&&&&&&&%%%&&&&&&&&&&&&%%%&%&%&%%%%%%%&&&&&&%%@,..,.................,..,,,,,,
# .................,,....,,/#&&%#%%((#%&&%&%&&%%%%%%%%%%%%%%%%%%%%%%&&&&&%%%%%%%%%&&&&&%&&%&(,*,,..................,..,,,,
# .............................,,.(&%%%%%&%&%%%&&%%%%%%&&&&@&&%####(%#/%@@@%///////&@&&@@@&(**///&,,.,.................,,,
# ................................,#&%&%%&%%&&&%##((((((((((((((%&&@@&(////*/////(###&@&&%///#(///%/.....................,
# ................................,.&&%#((((((((((((((((((##&@@@%#/*/((#%(/*,&@@@(//*/#&&//#///////&,,...................,
# ................................,%((((((((((((((#%%(/////#%@@@@@@@@@@&,,.,@@@@@&*///*##//&(((////&,,................,,..
# ........,..,...,............,..(%((##&%#(/*/(%%&@@@@//////&@@@@@@@@@%.,,,@@@@@@@*/////*/////#///(#,.....................
# ......,...*@/*##...........,.,.../&@@@@@@@#.,.(@@@@@%#/////%@@@@@@@(,,.*@@@@@@@%///////**//////&*..,....................
# ...........#(///%(..,.............&@@@@@@*,..#@@@@@@//////*//%@@@@*,,.,@@@@@@@@///////#&%%#%%(,.........................
# .......,.,,,,&(/*/&*.,..........,,,&@@@&,.,.(@@@@@@(////////////%/,.,/@@@@@@%/*///////#*.....,,.........................
# ......,....,..*&///(%..,............#@%,.,,#@@@@@@///*(#/*///////////*//////////*////&*......,,.........................
# .......,.,.,#(/*#//*/&,,,.........,...(%,.#@@@@&(//*//*///////////////////////////*#%,......,.,.........................
# .......,,##/((//#/*///%/...............,&///**///////////(@&&&#///////////////*//##/////#((%&(,,........................
# .......,%##/#%((##%(((/((.,..........,.,,&(*///*//////////&&@%&//////////////*/%((((//((%/(((/((%%/,..,.................
# ......,(%//#(*//////////(%....,...........,#&(/////////////(#///////////*/*(%(((((((//(#((((((((((%((&#,.,,.............
# ........,&%/%/*/#/*///*//((,..............,.,,*&&(///////////*/*///////#&#(/((((((((/*(##(((((((##((%///*%%,.,..........
# ..........,&(/////#/*//////&,.,........,,...#&#((/((((#&#(//*//**(&#((/(/#((((((((/((*/(%((((//(#((#/////////&/...,,....
# ............,(%/*////*///////%*........./&#((((%(((((((%((((((##*#(((((##&((((((((((((*(#%(((((&((#///////*/*///#%,.,...
# ...........,,..,&/////////////*%(...,(&###((((((%((((((%((((##%#(%((@&((((//////((%%(((*/(%*%&%((((/*//////////////#%,..
# ................,,%*/////////*//*#@%//(#((##(((((%/(((((((/(((((((%/(((((/,*/((#%&%#%(((//%/,,.,#&(///////////////////&/
# .................,.*%////////*//*///%//*/#((#(((((%((((((((#%@%(,%(%(((((%((((((((%#(#((//(#.,,.,,,./&(/////////////////
# ................,.,..*&//////////////////*(#((%(&/,@(((&(%###&%#(#(#((((((#/*/(##((/(&(*/((&.,........,./&////*/////////
# .....................,.*&///////////**///*//%&/,,..,(%((#/(((((##(##%(((((#((/*//((/*/#((/(&,........,,.,..##*//////////
# ......................,.,,&(/////////////(&*...,.....,&((%(((((((((#(##&&((#(((##%%#(((((((%/................/%/////////
# .......................,..,,#%*///////(&,.,..........,.##(#(((((((((%##(/((((((((((((((((((##.................,,&///////
# ............................,,(%///%&,...............,../&(&%%((((((((%(((((((((((((((((((((#,..................,,&////*
# ............................,.,.,/,,.,....,............,,,&((((((((((((#((((((((((((((((((((&,.....................,@//*

__author__ = "AIShield"
__copyright__ = "Copyright @2023 Bosch Global Software Technologies Private Limited."
__credits__ = "AIShield"
__license__ = "Apache-2.0"
__version__ = "1.0"
__maintainer__ = "AIShield"
__email__ = "AIShield.Contact@bosch.com"
__status__ = "Beta"

# import os level libraries
import os
import re
import json
import subprocess
# from util import utils
from presidio_analyzer import AnalyzerEngine
from presidio_analyzer.recognizer_registry import RecognizerRegistry

def filter_unique_packages(lst):
    """
    from list with duplicate packages, retain unique packages
    Parameters
    ----------
    lst :

    Returns
    -------

    """
    # remove duplicate packages detected
    unique_packages_dict = {}
    for package in lst:
        name = package.split("==")[0]
        if name in unique_packages_dict:
            # Retain the versioned package if it exists
            if '==' in package:
                unique_packages_dict[name] = package
        else:
            unique_packages_dict[name] = package

    # Convert dictionary values to a list for the final result
    unique_packages = list(unique_packages_dict.values())
    return unique_packages

def run_command_capture_output(command, directory):
    """
        Description:
        This function runs a shell command in a specified directory and captures
        its standard output (stdout) and standard error (stderr).

        Parameters:
        command (str): The shell command to be executed.
        directory (str): The directory in which the command should be executed.

        Return Value:
        The captured standard output (stdout) of the executed command.
        The captured standard error (stderr) of the executed command.

    """
    # Save the current working directory
    original_directory = os.getcwd()

    # Change the working directory to the specified directory
    os.chdir(directory)

    # Execute the shell command as a subprocess and capture stdout and stderr
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = process.communicate()

    # Restore the original working directory
    os.chdir(original_directory)

    # Decode the captured stdout and stderr and return them as strings
    return stdout.decode(), stderr.decode()


# %%
def convert_ipynb_to_py_format(file_name):
    """
        Description: This function converts a Jupyter Notebook (.ipynb) file to a Python (.py)
        script file using the jupyter nbconvert command-line tool.

        Parameters:
        file_name (str): The name of the input Jupyter Notebook file (.ipynb) to be converted.

        Return Value:
        py_file_name (str): The name of the generated Python script file (.py) after the conversion.
    """

    # Step 1: Print a message to indicate the start of the conversion
    print("Converting ipynb_file_name {} started".format(file_name))
    py_file_name = None
    try:
        # Step 2: Use 'jupyter nbconvert' to convert the .ipynb file to a Python script
        stdout, stderr = run_command_capture_output(f'jupyter nbconvert --to script {file_name}', os.getcwd())

        # Step 3: Generate the name of the .py file from the .ipynb file example of nbconvert out is : '[
        # NbConvertApp] Converting notebook test.ipynb to script\r\n[NbConvertApp] Writing
        # 42404 bytes to test.py\r\n'
        # So Here first were splitting in \r\n and got the second line and again split from
        # " " and get the last value , that will be the converted filename from the nbconvert
        py_file_name = stderr.split(" ")[-1].replace("\r", "").replace("\n", "").replace(" ", "")

    except Exception as e:
        # Handle exceptions and print an error message if conversion fails
        print("Converting ipynb_file_name to {} Failed {}".format(file_name, str(e)))

    # Step 4: Print a message to indicate the completion of the conversion
    print("Converting ipynb_file_name to {} Completed".format(py_file_name))

    # Step 5: Return the name of the generated .py file
    return py_file_name


# %%

def extract_packages_from_ipynb_file(filename):
    """
    Description:
    This function extracts Python package names from a Jupyter Notebook (.ipynb) file that contains 'pip install'
    statements. It then generates a requirements.txt file with the extracted package names.

    Parameters:
    filename (str): The name of the input Jupyter Notebook file (.ipynb) to be processed.

    Return Value:
    req_file_name (str): The name of the generated requirements.txt file that contains the extracted package names.
                        An empty string is returned if no 'pip install' statements are found.

    """
    req_file_name = ""
    try:
        with open(filename, 'r', encoding="utf8") as file:
            content = file.readlines()

        packages_with_versions = []
        for line in content:
            # if 'pip install' in line:
            pattern = r"(?:import\s+(\w+)|from\s+(\w+)\s+import|pip\s+install\s+(\w+))"
            
            if 'get_ipython' in line:
                match = re.search(r"pip install (\S+)'", line)
            else:
                match = re.search(pattern, line)
                
            if match:
                package_name = match.group(1)
                if package_name is not None:
                    packages_with_versions.append(package_name)
                    
      
        # Convert dictionary values to a list for the final result
        unique_packages = filter_unique_packages(packages_with_versions)

        if len(unique_packages) != 0:
            req_file_name = filename.replace(".py", "") + '_requirements.txt'
            with open(req_file_name, 'w') as file:
                for package in unique_packages:
                    file.write(package + '\n')

    except Exception as e:
        print("Error in Extracting Packages from Notebook due to {}".format(str(e)))

    return req_file_name


# %%
def requirement_file_scanning(file_name):
    """
    Description:
    This function performs a security scan on a requirement file (e.g., requirements.txt) using the "safety" tool.
    It runs the "safety check" command as a subprocess to scan the specified requirement file for known security
    vulnerabilities and returns the results in JSON format.

    Parameters:
    file_name (str): The path to the requirement file (e.g., requirements.txt) to be scanned.

    Return Value:
    json_output (dict): A dictionary containing the results of the scanning process in JSON format.
                       The JSON structure and content may vary depending on the "safety" tool's output.
                       If no security vulnerabilities are found or an error occurs during scanning, an empty dictionary
                       is returned.
    scanning_status (str): A string indicating the status of the scanning process, either "Success"
                            if the scan completed
                           without errors, or an error message if an exception occurred during scanning.

    """

    json_output = dict()  # Initialize an empty dictionary for scanning results
    scanning_status = "Success"  # Initialize the scanning status as "Success"
    try:
        # Run the "safety check" command as a subprocess and capture its stdout and stderr
        stdout, stderr = run_command_capture_output(f'safety check -r {file_name} --output json', os.getcwd())

        # If stdout is not empty, attempt to parse it as JSON
        if len(stdout) != 0:
            # Parse the JSON output
            json_output = json.loads(stdout)

            # Include stderr information in the JSON output
            json_output.update(stderr)

    except subprocess.CalledProcessError as e:
        # Handle exceptions related to running the "safety check" command
        scanning_status = "Failed {}".format(str(e))
        print("Error running Safety scan:", e)
        print("Error output :{}", format(str(e)))

    except Exception as e:
        # Handle other exceptions
        scanning_status = "Failed {}".format(str(e))
        print("Error running Safety scan:", e)
        print("Error output :{}", format(str(e)))

    return json_output, scanning_status


# %%
def detect_secrets_scanning(file_name):
    """
    Description:
    This function performs scanning using the "detect-secert" tool on the content of a given file.
    It runs the "detect-secert" command as a subprocess to scan the specified file for sensitive information and returns
    the results in JSON format.

    Parameters:
    file_name (str): The path to the file to be scanned.

    Return Value:
    json_output (dict): A dictionary containing the results of the scanning process in JSON format.
                       The JSON structure and content may vary depending on the "detect-secert" tool's output.
                       If no results are found or an error occurs during scanning, an empty dictionary is returned.
    scanning_status (str): A string indicating the status of the scanning process, either "Success"
                            if the scan completed
                           without errors, or an error message if an exception occurred during scanning.
    """

    json_output = dict()  # Initialize an empty dictionary for scanning results
    scanning_status = "Success"  # Initialize the scanning status as "Success"
    try:
        # Run the "detect-secrets" command as a subprocess and capture its stdout and stderr
        stdout, stderr = run_command_capture_output(f'detect-secrets scan {file_name}', os.getcwd())

        # If stdout is not empty, attempt to parse it as JSON
        if len(stdout) != 0:
            json_output = json.loads(stdout)
            json_output.update(stderr)

    except subprocess.CalledProcessError as e:
        # Handle exceptions related to running the "detect-secrets" tool
        scanning_status = "Failed {}".format(str(e))
        print("Error running detect-secrets scan:", e)
        print("Error output :{}", format(str(e)))

    except Exception as e:
        # Handle other exceptions
        scanning_status = "Failed {}".format(str(e))
        print("Error running detect-secrets scan:", e)
        print("Error output :{}", format(str(e)))

    return json_output, scanning_status


# %%
def whisper_scanning(file_name):
    """
    Description:
    This function performs sensitive data scanning using the "whispers" tool on the content of a given file.
    It runs the "whispers" command as a subprocess to scan the specified file for sensitive information and returns
    the results in JSON format.

    Parameters:
    file_name (str): The path to the file to be scanned.

    Return Value:
    json_output (dict): A dictionary containing the results of the scanning process in JSON format.
                       The JSON structure and content may vary depending on the "whispers" tool's output.
                       If no results are found or an error occurs during scanning, an empty dictionary is returned.
    scanning_status (str): A string indicating the status of the scanning process, either "Success"
                           if the scan completed
                           without errors, or an error message if an exception occurred during scanning.
    """

    json_output = dict()  # Initialize an empty dictionary for scanning results
    scanning_status = "Success"  # Initialize the scanning status as "Success"
    try:
        # Run the "whispers" command as a subprocess and capture its stdout and stderr
        stdout, stderr = run_command_capture_output(f'whispers {file_name}', os.getcwd())

        # If stdout is not empty, attempt to parse it as JSON
        if len(stdout) != 0:
            json_output = json.loads(stdout)

    except subprocess.CalledProcessError as e:
        # Handle exceptions related to running the "whispers" tool
        scanning_status = "Failed {}".format(str(e))
        print("Error running whispers scan:", e)
        print("Error output :{}", format(str(e)))

    except Exception as e:
        # Handle other exceptions
        scanning_status = "Failed {}".format(str(e))
        print("Error running whispers scan:", e)
        print("Error output :{}", format(str(e)))

    return json_output, scanning_status


# %%
def presidio_analyzer_scanning(file_name):
    """
    Description:
    This function performs sensitive data scanning using the Presidio Analyzer on the content of a given file.
     It analyzes the file's text content for specific entities such as PERSON names,
      EMAIL_ADDRESS, LOCATION, PHONE_NUMBER, and US_SSN.

    Parameters:
    file_name (str): The path to the file to be scanned.

    Return Value:
    str_output (str): A string containing the findings from the scanning process. Each finding includes details such as
                     the type of entity, line number, content snippet, start and end positions, and a score.
                     This string may be empty if no sensitive data entities are found.
   
    scanning_status (str): A string indicating the status of the scanning process, either "Success" if the
                           scan completed without errors, or an error message if an exception occurred during scanning.
    """

    str_output = ""  # Initialize the findings string
    scanning_status = "Success"  # Initialize the scanning status as "Success"

    try:

        # Initialize Presidio Analyzer components
        recognizer_registry = RecognizerRegistry()
        analyzer = AnalyzerEngine(registry=recognizer_registry)

        # Read the content of the specified file
        with open(file_name, 'r', encoding="utf8") as file:
            content = file.read()

        # Define the entities to be analyzed by Presidio Analyzer
        entities_to_analyze = ["PERSON", "EMAIL_ADDRESS", "LOCATION", "PHONE_NUMBER", "US_SSN"]

        # Analyze the content for specified entities
        results = analyzer.analyze(text=content, entities=entities_to_analyze, language='en')
        findings = []

        # Process the analysis results
        for result in results:
            if result.score < 0.5:
                continue
            # Get line details for the position of the finding
            line_number, line_content = get_line_details_from_position(content, result.start)

            # Check if the line is likely code and skip it if true
            if is_likely_code(line_content):
                continue

            # Format the finding details
            findings.append(f"Type: {result.entity_type}, Line: {line_number}, "
                            f"Content: '{line_content}', Start: {result.start},"
                            f" End: {result.end}, Score: {result.score}")

        # If findings were detected, join them into a formatted string
        if len(findings) != 0:
            str_output = "\n".join(findings)

    except subprocess.CalledProcessError as e:
        # Handle exceptions related to running Presidio Analyzer
        scanning_status = "Failed {}".format(str(e))
        print("Error running presidio_analyzer scan:", e)
        print("Error output :{}", format(str(e)))

    except Exception as e:
        # Handle other exceptions
        scanning_status = "Failed {}".format(str(e))
        print("Error running presidio_analyzer scan:", e)
        print("Error output :{}", format(str(e)))
    return str_output, scanning_status


# %%
def get_line_details_from_position(content, position):
    """
    Description:
    This function retrieves line details from a given position 
    within a text content string.

    Parameters:
    content (str): The input text content string.
    position (int): The character position within the content string (0-based index).

    Return Value:
    line_number (int): The line number containing the specified position.
    line_content (str): The content of the line containing the specified position, stripped of
    leading and trailing whitespace.
    """

    # Split the content into lines
    lines = content.split('\n')

    # Calculate the line number containing the specified position
    line_number = content.count('\n', 0, position) + 1

    # Retrieve the content of the line containing the specified position
    line_content = lines[line_number - 1].strip()
    return line_number, line_content


def is_likely_code(line_content):
    """
    Description:
    This function determines whether a given line of text content is likely to 
    be code based on certain patterns and keywords.

    Parameters:
    line_content (str): The content of a single line of text.

    Return Value:
    is_code (bool): True if the line is likely code; False otherwise.
    
    """

    # Check if the line starts with an import statement
    if line_content.startswith(('import ', 'from ')):
        return True

    # List of common code-related words and keywords
    common_code_words = ['train', 'test', 'def ', 'class ', 'return', 'if ', 'else', 'for ', 'while ', 'nltk',
                         'transform', 'ipython', 'model', 'relu']

    # Check if any of the common code words are present in the line content
    if any(word in line_content for word in common_code_words):
        return True

    # If none of the code patterns were found, consider it as not likely code
    return False


# %%


def has_whitespace_character(file_name, whitespace_character: str = " "):
    """
    Description:
    This function determines whether a file name has whitespace character or not ,
    if yes , then replace whitespace character in here and rename the file name.

    Parameters:
    file_name (str): relative path of the file
    whitespace_character (str) : default is  " "


    Return Value:
    file_name (str): if no whitespace character , return actual file_name
    or f_name (str) : if whitespace character, return the new file name
    
    """

    # get the actual file name 
    f_path, f_name = os.path.split(file_name)

    if whitespace_character in f_name:
        # if any whitespace character is there replace with above-mentioned
        # and rename the file
        f_name = os.path.join(f_path, f_name.replace(whitespace_character, ""))
        # rename the file name 
        os.rename(file_name, f_name)
        # return the updated file name 
        return f_name
    else:
        # return the original file name
        return file_name
